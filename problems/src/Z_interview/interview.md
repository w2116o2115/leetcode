## 总结

- 细说JVM（虚拟机实现多态）
```
方法调用：
    在介绍Class文件的时候我们知道，Class文件的编译过程并不包含传统编译的连接阶段，Class文件中方法都是以符号引用的形式存储的，
    而不是方法的入口地址（直接引用）。这个特性使得Java具有强大的动态扩展的能力，但同时也增加了Java方法调用过程的复杂性，因为
    方法需要在类加载期间甚至是运行时才能确定真正的入口地址，即将符号引用转换为直接引用。

    invokestatic：调用静态方法；
    invokespecial：调用实例构造器<init>方法、私有方法和父类方法；
    invokevirtual：调用所有的虚方法；
    invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象；
    invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的4条调用指令，分派逻辑都是固化在Java虚
    拟机中的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。
    
虚拟机如何实现动态分派
    由于动态分派是非常频繁的操作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法，因此虚拟机会进
    行优化。常用的方法就是为类在方法区中建立一个虚方法表（Virtual Method Table，在invokeinterface执行时也会用到接口方法表，
    Interface Method Table），使用虚方法表索引来替代元数据查找以提升性能。
    
    虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址
    入口是一致的，都指向父类的实现入口。如果子类重写了父类的方法，子类方法表中的地址会替换为指向子类实现版本的入口地址。
    
    为了程序实现上的方便，具有相同签名的方法，在父类和子类的虚方法表中都应该具有一样的索引号，这样当类型变换时，仅仅需要变更查
    找的方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。
    
    方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。
```

- 为什么HashMap是线程不安全
```
1. resize死循环
    我们都知道HashMap初始容量大小为16,一般来说，当有数据要插入时，都会检查容量有没有超过设定的thredhold，如果超过，需要增大
    Hash表的尺寸，但是这样一来，整个Hash表里的元素都需要被重算一遍。这叫rehash，这个成本相当的大。
    
    大概看下transfer：
    
    对索引数组中的元素遍历
    对链表上的每一个节点遍历：用 next 取得要转移那个元素的下一个，将 e 转移到新 Hash 表的头部，使用头插法插入节点。
    循环2，直到链表节点全部转移
    循环1，直到所有索引数组全部转移
    
    经过这几步，我们会发现转移的时候是逆序的。假如转移前链表顺序是1->2->3，那么转移后就会变成3->2->1。这时候就有点头绪了，死锁
    问题不就是因为1->2的同时2->1造成的吗？所以，HashMap 的死锁问题就出在这个transfer()函数上。
```

- Netty内存池设计
```
1. resize死循环
    我们都知道HashMap初始容量大小为16,一般来说，当有数据要插入时，都会检查容量有没有超过设定的thredhold，如果超过，需要增大
    Hash表的尺寸，但是这样一来，整个Hash表里的元素都需要被重算一遍。这叫rehash，这个成本相当的大。
    
    大概看下transfer：
    
    对索引数组中的元素遍历
    对链表上的每一个节点遍历：用 next 取得要转移那个元素的下一个，将 e 转移到新 Hash 表的头部，使用头插法插入节点。
    循环2，直到链表节点全部转移
    循环1，直到所有索引数组全部转移
    
    经过这几步，我们会发现转移的时候是逆序的。假如转移前链表顺序是1->2->3，那么转移后就会变成3->2->1。这时候就有点头绪了，死锁
    问题不就是因为1->2的同时2->1造成的吗？所以，HashMap 的死锁问题就出在这个transfer()函数上。
```
